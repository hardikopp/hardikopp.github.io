<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardik Kumar Bihari - Portfolio</title>
    <style>
        @import url('https://fonts.cdnfonts.com/css/sf-pro-display');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: #000;
            color: white;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0, 119, 255, 0.15) 0%, transparent 25%),
                radial-gradient(circle at 80% 70%, rgba(226, 0, 116, 0.15) 0%, transparent 25%);
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #portfolio {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease-in-out;
            z-index: 2;
        }

        #portfolio.visible {
            opacity: 1;
            pointer-events: all;
        }

        .name {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 2rem;
            text-align: center;
            background: linear-gradient(90deg, #ff8a00, #e52e71, #0077ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradientShift 8s ease infinite;
            background-size: 300% 300%;
        }

        .enter-btn {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background: linear-gradient(45deg, #0077ff, #00ffcc);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            font-family: 'SF Pro Display', sans-serif;
            font-weight: 500;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .enter-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 119, 255, 0.3);
        }

        .enter-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #00ffcc, #0077ff);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .enter-btn:hover::before {
            opacity: 1;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @media (max-width: 768px) {
            .name {
                font-size: 2.5rem;
            }
            
            .enter-btn {
                font-size: 1.2rem;
                padding: 0.8rem 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="portfolio">
        <h1 class="name">HARDIK KUMAR BIHARI</h1>
        <button class="enter-btn" onclick="window.location.href='portfolio.html'">ENTER PORTFOLIO</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Particle Animation
        const canvasContainer = document.getElementById('canvas-container');
        const portfolioSection = document.getElementById('portfolio');

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        canvasContainer.appendChild(renderer.domElement);

        // Particles
        const particleCount = 3000;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        // Initialize particles in random positions with blue/purple color scheme
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 2000;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;

            // Blue/purple color scheme
            colors[i * 3] = Math.random() * 0.2 + 0.1; // R
            colors[i * 3 + 1] = Math.random() * 0.3; // G
            colors[i * 3 + 2] = Math.random() * 0.5 + 0.5; // B

            sizes[i] = Math.random() * 3 + 1;
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Particle material
        const particleMaterial = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // Camera position
        camera.position.z = 500;

        // Animation state
        let animationState = 'scatter'; // scatter, forming, formed, fading
        let animationStartTime = Date.now();
        const formDuration = 4000; // 4 seconds to form name
        const displayDuration = 3000; // 3 seconds displaying name
        const fadeDuration = 2000; // 2 seconds fading out

        // Name positions (simplified for demo - would need proper 3D modeling for accurate representation)
        const namePositions = [];
        const name = "HARDIK KUMAR BIHARI";
        const nameSegments = 20; // segments per letter (simplified)

        // Generate target positions for the name (simplified)
        for (let i = 0; i < name.length; i++) {
            for (let j = 0; j < nameSegments; j++) {
                const x = (i - name.length / 2) * 30;
                const y = 0;
                const z = 0;
                namePositions.push(x, y, z);
            }
        }

        // Make sure we have enough positions
        while (namePositions.length < particleCount * 3) {
            namePositions.push(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100
            );
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const elapsed = currentTime - animationStartTime;

            // Rotate particles in scatter state
            if (animationState === 'scatter') {
                particleSystem.rotation.x += 0.001;
                particleSystem.rotation.y += 0.002;

                // Switch to forming after 3 seconds
                if (elapsed > 3000) {
                    animationState = 'forming';
                    animationStartTime = currentTime;
                }
            } 
            // Form the name
            else if (animationState === 'forming') {
                const progress = Math.min(elapsed / formDuration, 1);
                
                // Move particles to name positions
                const positions = particles.attributes.position.array;
                const originalPositions = particles.attributes.position.originalPositions || 
                                        [...particles.attributes.position.array];
                
                // Store original positions if not already stored
                if (!particles.attributes.position.originalPositions) {
                    particles.attributes.position.originalPositions = originalPositions;
                }
                
                for (let i = 0; i < positions.length; i++) {
                    const originalPos = originalPositions[i];
                    const targetPos = namePositions[i] || 0;
                    positions[i] = originalPos + (targetPos - originalPos) * progress;
                }
                
                particles.attributes.position.needsUpdate = true;
                
                // Switch to formed state when complete
                if (progress >= 1) {
                    animationState = 'formed';
                    animationStartTime = currentTime;
                }
            } 
            // Display the formed name
            else if (animationState === 'formed') {
                if (elapsed > displayDuration) {
                    animationState = 'fading';
                    animationStartTime = currentTime;
                }
            } 
            // Fade out the name
            else if (animationState === 'fading') {
                const progress = Math.min(elapsed / fadeDuration, 1);
                particleMaterial.opacity = 1 - progress;
                
                // Show portfolio section when fade is complete
                if (progress >= 1) {
                    portfolioSection.classList.add('visible');
                    // Stop animation to save resources
                    return;
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        // Start animation
        animate();
    </script>
</body>
</html>